/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var geometry = 
    /* color: #ffc82d */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-72.31295735716925, 2.9494364109240045],
          [-72.31295735716925, 2.6305251294291145],
          [-71.60845906615363, 2.6305251294291145],
          [-71.60845906615363, 2.9494364109240045]]], null, false),
    geometry4 = /* color: #0b4a8b */ee.Geometry.Polygon(
        [[[-74.35494272502784, 3.0115143268669766],
          [-73.73970835002784, 2.6603829406882786],
          [-73.81661264690284, 2.545145518884566],
          [-73.09700815471534, 1.7546929852528748],
          [-72.31697885784034, 1.7217491674799459],
          [-71.61385385784034, 3.03345641723607],
          [-74.43184702190284, 3.411884649503958]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
var Region_100K = ee.FeatureCollection("projects/pc300-samz-sinchi/assets/Region_100K");

var aoi = Region_100K.first().geometry();
var region = aoi.buffer(100);
var region=geometry4;
//Decalrar variables
var start_year = 2022;
var start_month = 1;
var start_day = 1;
var end_year = 2022;
var end_month = 7;
var end_day = 31;


var module_extract_samples = require('users/an-sig/sinchi:classification/module_extract_samples');
var moduloComposite= require('users/an-sig/sinchi:classification/composition');
var moduloCovariates= require('users/an-sig/sinchi:classification/covariates');

// Ejecutar la función y recibe los resultados
var visualizationResults = module_extract_samples.executeAndVisualize();
var balanceAndApplyCorrelation=module_extract_samples.balanceAndApplyCorrelation;


// Traer puntos de muestreo para semestre 1 
//Tenemos unafeature collection para muestreos de entrenamiento y validacion
//el atributo (columna) a traves del cual se hara la cllasificacion es nivel_1
var S1_training=visualizationResults.combinedResults_S1.training;
var S1_testing=visualizationResults.combinedResults_S1.testing;


var processedImage = moduloComposite.s2process(region, start_year, end_year, start_month, start_day,end_month, end_day);


var image_covariates=moduloCovariates.returnCovariates(processedImage);
var image_covariates=image_covariates.clip(region);

print("image_covariates2",image_covariates);

var bandInfo = processedImage.bandTypes();print('Band Information:', bandInfo);

var visualizationParams = {  "bands": ["swir1_p50", "nir_p50", "swir2_p50"],
  "min": [200, 200,200],
  "max": [5000,5000,50000],
  "gamma": 0.5,
}; // Ajusta según tus bandas


Map.addLayer(processedImage,visualizationParams,'processedImage');


// Correr RF
function RFprim(trainingPts, inputImage) {
    var trainingData = inputImage.sampleRegions({
        collection: trainingPts,
        properties: ['nivel_1'],
        scale: 20
    });

    var classifier = ee.Classifier.smileRandomForest(100).train({
        features: trainingData,
        classProperty: 'nivel_1',
        inputProperties: inputImage.bandNames()
    });

    return inputImage.classify(classifier);
}


// Entrenar el clasificador con los puntos de entrenamiento
var classifiedImage = RFprim(S1_training, processedImage);
//var classifiedImage  = classifiedImage .multiply(255).toByte();

print("classifiedImage ",classifiedImage )



/*
Script para calcular exactitud
test

*/

var S1_testing_classified= classifiedImage.sampleRegions({
  collection: S1_testing,
  scale: 20,
  geometries: true
});


print("S1_testing_classified",S1_testing_classified)


var combineValues = function(feature) {
    var nivel_1 = feature.get('nivel_1');
    var classification = feature.get('classification');
    return ee.Feature(null, {
        'nivel_1': nivel_1,
        'classification': classification
    });
};

// Map this function over the FeatureCollection
var separateValues = S1_testing_classified.map(combineValues);

print("separateValues", separateValues);


// Extract nivel_1 and classification values
var nivel_1List = separateValues.aggregate_array('nivel_1');
var classificationList = separateValues.aggregate_array('classification');


nivel_1List.evaluate(function(nivel_1List) {
    print("nivel_1Values", nivel_1List);
    classificationList.evaluate(function(classificationList) {
        print("classificationValues", classificationList);
        if (nivel_1List && classificationList) {
            var results = calculateMetrics(nivel_1List, classificationList);
            console.log('Results:', results);
        } else {
            console.log('Data is not available for processing.');
        }
    });
});

var calculateMetrics = function(nivel_1List, classificationList) {
    var matrix = {};
    var total = 0;
    var correct = 0;
    var classCounts = {};

    nivel_1List.forEach(function(n1, index) {
        var classPred = classificationList[index];
        var key = n1 + '-' + classPred;
        matrix[key] = (matrix[key] || 0) + 1;

        // Count correct predictions
        if (n1 === classPred) {
            correct++;
        }

        // Initialize class counts
        classCounts[n1] = classCounts[n1] || {total: 0, correct: 0, predicted: 0};
        classCounts[classPred] = classCounts[classPred] || {total: 0, correct: 0, predicted: 0};

        // Increment class counts
        classCounts[n1].total++;
        classCounts[classPred].predicted++;
        if (n1 === classPred) {
            classCounts[n1].correct++;
        }

        total++;
    });

    // Calculate accuracy and errors
    var accuracy = correct / total;
    var commissionErrors = {};
    var omissionErrors = {};
    Object.keys(classCounts).forEach(function(c) {
        commissionErrors[c] = 1 - (classCounts[c].correct / (classCounts[c].predicted || 1));
        omissionErrors[c] = 1 - (classCounts[c].correct / classCounts[c].total);
    });

    return {
        confusionMatrix: matrix,
        accuracy: accuracy,
        commissionErrors: commissionErrors,
        omissionErrors: omissionErrors
    };
};

// Perform the operation client-side
nivel_1List.evaluate(function(n1Values) {
    classificationList.evaluate(function(classificationValues) {
        var results = calculateMetrics(n1Values, classificationValues);
        print('Confusion Matrix:', results.confusionMatrix);
        console.log('Confusion Matrix:', results.confusionMatrix);
        console.log('Overall Accuracy:', results.accuracy);
        console.log('Commission Errors:', results.commissionErrors);
        console.log('Omission Errors:', results.omissionErrors);
    });
});

// Mostrar los resultados
//print("combinedResults_S1.training", visualizationResults.combinedResults_S1.training);
//print("combinedResults_S1.testing", visualizationResults.combinedResults_S1.testing);
//print("combinedResults_S2.training", visualizationResults.combinedResults_S2.training);
//print("combinedResults_S2.testing", visualizationResults.combinedResults_S2.testing);

// Agregar las capas de los puntos de muestreo al mapa
//Map.addLayer(visualizationResults.combinedResults_S1.training, {color: 'blue'}, 'Training Points S1');
Map.addLayer(visualizationResults.combinedResults_S1.testing, {color: 'red'}, 'Testing Points S1');
//Map.addLayer(visualizationResults.combinedResults_S2.training, {color: 'green'}, 'Training Points S2');
//Map.addLayer(visualizationResults.combinedResults_S2.testing, {color: 'yellow'}, 'Testing Points S2');

// Centrar el mapa en uno de los conjuntos de puntos
Map.centerObject(visualizationResults.combinedResults_S1.training);
var exportParams = {
  image: classifiedImage,
  description: 'classified_image_export',
  fileNamePrefix: 'classified_image',
  scale: 32,  // Debe coincidir con la resolución utilizada para el análisis
  region: region,  // Especifica la región que deseas exportar
  fileFormat: 'GeoTIFF',
  maxPixels: 1e13  // Ajusta según las necesidades
};
Export.image.toDrive(exportParams);

// Mostrar imagen clasificada en mapa:
// Suponiendo que classifiedImage es tu imagen de clasificación

// Definir la paleta de colores y nombres de clases
var palette = ['red', 'green', 'blue', 'yellow', 'purple']; // Colores
var classNames = ['Territorios Artificializados', 'Terriotrios Agrícolas',
'Bosques y áreas seminaturales', 'Areas húmedas', 'Superficies de agua']; // Nombres

// Parámetros de visualización para la imagen
var visualizationParams = {
  min: 1,
  max: 5,
  palette: palette
};

// Agregar la imagen al mapa
//Map.addLayer(classifiedImage, visualizationParams, 'Imagen Clasificada');
// Crear un panel para la leyenda
var legend = ui.Panel({
  style: {
    position: 'bottom-left',
    padding: '8px 15px'
  }
});

// Agregar título a la leyenda
var legendTitle = ui.Label({
  value: 'Leyenda',
  style: {
    fontWeight: 'bold',
    fontSize: '16px',
    margin: '0 0 4px 0',
    padding: '0'
  }
});
legend.add(legendTitle);

// Agregar las entradas de la leyenda
classNames.forEach(function(name, index){
  var color = palette[index];
  var label = ui.Label({
    value: name,
    style: {
      color: 'black',
      backgroundColor: color,
      margin: '2px',
      padding: '2px'
    }
  });
  legend.add(label);
});

// Agregar la leyenda al mapa
Map.add(legend);

