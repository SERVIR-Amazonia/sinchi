/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var geometry = 
    /* color: #ffc82d */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-72.31295735716925, 2.9494364109240045],
          [-72.31295735716925, 2.6305251294291145],
          [-71.60845906615363, 2.6305251294291145],
          [-71.60845906615363, 2.9494364109240045]]], null, false);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
var Region_100K = ee.FeatureCollection("projects/pc300-samz-sinchi/assets/Region_100K");
var aoi =geometry
//var aoi = Region_100K.first().geometry();
var region = aoi.buffer(100);
//Decalrar variables
var start_year = 2022;
var start_month = 7;
var start_day = 1;
var end_year = 2022;
var end_month = 12;
var end_day = 31;


var miModulo = require('users/an-sig/sinchi:classification/Module_extract_samples');
var moduloComposite= require('users/an-sig/sinchi:classification/composition');
var moduloCovariates= require('users/an-sig/sinchi:classification/covariates');

// Ejecutar la función y recibe los resultados
var visualizationResults = miModulo.executeAndVisualize();
var balanceAndApplyCorrelation=miModulo.balanceAndApplyCorrelation


// Traer puntos de muestreo para semestre 1 
//Tenemos unafeature collection para muestreos de entrenamiento y validacion
//el atributo (columna) a traves del cual se hara la cllasificacion es nivel_1
var S1_training=visualizationResults.combinedResults_S1.training;
var S1_testing=visualizationResults.combinedResults_S1.testing;


var processedImage = moduloComposite.s2process(region, start_year, end_year, start_month, start_day,end_month, end_day);
print("processedImage",processedImage);
//var image_covariates=moduloCovariates.returnCovariates(processedImage)
//var image_covariates=image_covariates.clip(region)

print("imagen", processedImage)
var visualizationParams = {  "bands": ["swir1_p50", "nir_p50", "swir2_p50"],
  "min": [190, 260, 240],
  "max": [6060,5000,5010],
  "gamma": 0.8,
}; // Ajusta según tus bandas


Map.addLayer(processedImage,visualizationParams,'processedImage');



// Correr RF
function RFprim(trainingPts, inputImage) {
    var trainingData = inputImage.sampleRegions({
        collection: trainingPts,
        properties: ['nivel_1'],
        scale: 30
    });

    var classifier = ee.Classifier.smileRandomForest(100).train({
        features: trainingData,
        classProperty: 'nivel_1',
        inputProperties: inputImage.bandNames()
    });

    return inputImage.classify(classifier);
}

// Entrenar el clasificador con los puntos de entrenamiento
var classifiedImage = RFprim(S1_training, processedImage);

//print("classifiedImage ",classifiedImage )

// Mostrar los resultados
//print("combinedResults_S1.training", visualizationResults.combinedResults_S1.training);
//print("combinedResults_S1.testing", visualizationResults.combinedResults_S1.testing);
//print("combinedResults_S2.training", visualizationResults.combinedResults_S2.training);
//print("combinedResults_S2.testing", visualizationResults.combinedResults_S2.testing);

// Agregar las capas de los puntos de muestreo al mapa
Map.addLayer(visualizationResults.combinedResults_S1.training, {color: 'blue'}, 'Training Points S1');
Map.addLayer(visualizationResults.combinedResults_S1.testing, {color: 'red'}, 'Testing Points S1');
//Map.addLayer(visualizationResults.combinedResults_S2.training, {color: 'green'}, 'Training Points S2');
//Map.addLayer(visualizationResults.combinedResults_S2.testing, {color: 'yellow'}, 'Testing Points S2');

// Centrar el mapa en uno de los conjuntos de puntos
Map.centerObject(visualizationResults.combinedResults_S1.training);