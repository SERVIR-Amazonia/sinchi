exports.rf =function RFprim(trainingPts, testingPts,inputImage) {
    var trainingData = inputImage.sampleRegions({
        collection: trainingPts,
        properties: ['nivel_1'],
        scale: 20
    });
    print(" trainingData 7 classify.rf", trainingData);
    
    var testingData = inputImage.sampleRegions({
        collection: testingPts,
        properties: ['nivel_1'],
        scale: 20
    });
    //print(" testingData", testingData)
    
    

    var classifier = ee.Classifier.smileRandomForest(100).train({
        features: trainingData,
        classProperty: 'nivel_1',
        inputProperties: inputImage.bandNames()
    });


    return {
        classified_image: inputImage.classify(classifier),
        rfclassifier: classifier,
        trainingData:testingData,
        testingData:testingData
        
    };
    
};

////////////////////////////////
//// Funciones para crear primitivos///////



function procesarDatos(S1_training, S1_testing, image_covariates) {
    // Función para convertir la propiedad 'nivel_1' de entero a string
    var convertNivel1ToString = function(feature) {
        // Obtener el valor actual de 'nivel_1' y convertirlo a string
        var nivel1String = ee.Number(feature.get('nivel_1')).format();

        // Establecer el valor convertido de vuelta en la propiedad 'nivel_1'
        return feature.set('nivel_1', nivel1String);
    };

    // Aplicar la función a cada Feature en el FeatureCollection
    var trainingDataUpdated = S1_training.map(convertNivel1ToString);
    trainingDataUpdated = image_covariates.sampleRegions({
        collection: trainingDataUpdated,
        properties: ['nivel_1'],
        scale: 20
    });

    // Imprimir el resultado actualizado de los datos de entrenamiento
    print("trainingDataUpdated", trainingDataUpdated);

    // Aplicar la función a los datos de prueba y retornar el resultado
    var testingDataUpdated = S1_testing.map(convertNivel1ToString);
    return trainingDataUpdated;
}




var formatPts=function (pts,clase) {
    // Turn a FC of training points containing full LC typology into a list of primitive point FCs, 
    // one point FC for each LC primitive

    // Create sets of binary training pts for each class represented in the full training pts collection
   //var labels = ee.FeatureCollection(pts).aggregate_array(clase.toString()).distinct().sort();
   var labels = ee.FeatureCollection(pts).aggregate_array(clase).distinct().sort();
   print("labels83",labels)
    function binaryPts(l) {
        // Create prim and non prim sets with filters, reset prim to 1, non-prim to 0
        var prim = pts.filter(ee.Filter.eq(clase, l)).map(function(f) {
            return f.set('PRIM', 1);
        });
        var nonPrim = pts.filter(ee.Filter.neq(clase, l)).map(function(f) {
            return f.set('PRIM', 0);
        });
        return ee.FeatureCollection(prim).merge(nonPrim);
    }

    var listOfPrimPts = ee.List(labels).map(binaryPts);
    //var listOfPrimPts = ee.List(labels).map(binaryPts);
    print("listOfPrimPts L 93_main",listOfPrimPts)
    
    return listOfPrimPts;
};



var getTop20=function (dict) {
    // If total input features count < 20, take them all, otherwise take top 20 most important
    dict = ee.Dictionary(dict);
    var values = dict.values().sort();
    //print("values 107",values)
    var cutoff = ee.Algorithms.If(values.size().gte(20), -20, values.size().multiply(-1));
    
    function kvReturn(key, passedObj) {
        passedObj = ee.List(passedObj);
        var val = ee.Number(dict.get(key));
        var retObj = ee.Algorithms.If(val.gte(cutoff), passedObj.add(key), passedObj);
        return retObj;
    }

    var newList = dict.keys().iterate(kvReturn, ee.List([]));
    //print("newList 130",newList)
    return newList;
};


// Función para verificar y manejar propiedades faltantes
function checkAndHandleMissingProperties(feature) {
    var requiredProperties = ['blue', 'green', 'red']; // y otras propiedades relevantes
    var defaultValue = 0; // Define un valor por defecto adecuado

    requiredProperties.forEach(function(prop) {
        // Crear una condición que verifique si la propiedad existe
        var condition = feature.propertyNames().contains(prop);

        // Usar 'ee.Algorithms.If' para manejar la propiedad faltante
        feature = ee.Feature(ee.Algorithms.If(condition, feature, feature.set(prop, defaultValue)));
    });

    return feature;
}


var RFprim=function (trainingPts,inputStack, label) {
    // Train and apply RF Probability classifier on a Primitive
    var inputs = ee.Image(inputStack);
    print("line 121 trainingPts",trainingPts);
    var samples = ee.FeatureCollection(trainingPts);
    print("samples",samples);
    // Aplicar esta función a todas las características en la colección
    samples = samples.map(checkAndHandleMissingProperties);
    var linea160=samples.sort('PRIM', false);
    print( linea160,"linea 161");
    var linea125=linea160.first();
    print("primeros features linea163",linea125);

    //var classValue = ee.Number(ee.Feature(samples.sort('PRIM', false).first()).get(clase));

    // Can experiment with classifier params for model performance
    var classifier = ee.Classifier.smileRandomForest({
        numberOfTrees: 100,
        minLeafPopulation: 1,
        bagFraction: 0.7,
        seed: 51515
    }).setOutputMode('PROBABILITY');

    // Train model with all features
    var model = classifier.train({
        features: samples,
        classProperty: 'PRIM',
        inputProperties: inputs.bandNames()
    });
    
    // Store for model performance exploration
    var explain=model.explain();
    print("explain 190",explain);
    var oobAll = ee.Dictionary(model.explain()).get('outOfBagErrorEstimate')
    var importanceAll = ee.Dictionary(model.explain()).get('importance');
    print("importanceAll 188",importanceAll);

    // Retrieve top 20 most important features
    var top20 = getTop20(importanceAll); // Ensure getTop20 function is defined in your script
    
    // Re-train model with top 20 important features
    model = classifier.train({
        features: samples,
        classProperty: 'PRIM',
        inputProperties: top20
    });
    print("model 200",model);

    var oobTop20 = ee.Dictionary(model.explain()).get('outOfBagErrorEstimate');
    var importanceTop20 = ee.Dictionary(model.explain()).get('importance');
    var schema = ee.List(ee.Classifier(model).schema());
    var output = inputs.classify(model, 'Probability')
                    .set({
                        'Primitive': 'nivel_1',
                        'importance': importanceTop20,
                        'schema': schema,
                        'model': model,
                        'oobError': oobTop20
                    });
    print("output 213",output);
    return output;
};

exports.createLCPrimitiveCollection=function(inputStack, trainingPts, label) {
    /*
    Create LC Primitive image for each LC class in training points.

    args:
        inputStack (ee.Image): of all covariates and predictor
        trainingPts (ee.FeatureCollection): training pts containing full LC typology
        className (str): property name in training points containing model classes
    
    returns:
        An object containing the ImageCollection, region, and training data
    */   
  
  
    inputStack = ee.Image(inputStack);
    print('Type of inputStack:', inputStack);
    trainingPts = ee.FeatureCollection(trainingPts);

    // list of distinct LANDCOVER values
    var labels = trainingPts.aggregate_array(clase).distinct().sort();


     var primList = ee.List([]);
 labels.getInfo().forEach(function(label) {
        var labelIndex = ee.Number.parse(label).subtract(1).toInt(); // Convertir la etiqueta a índice
        var formattedPtsList = formatPts(trainingPts, clase);

        var primPts = ee.FeatureCollection(formattedPtsList.get(labelIndex)); // Usar el índice para obtener los puntos
        print("primPts 245",primPts);
        var img = RFprim(primPts, inputStack, label);
        primList = primList.add(img);
    });
    print("primList 251",primList)
    return ee.ImageCollection.fromImages(primList);
};
///////////////

exports.calculateConfusionMatrix = function(testingSet, RFclassifier) {
    var confusionMatrix = testingSet.classify(RFclassifier)
        .errorMatrix({
            actual: 'nivel_1',
            predicted: 'classification'
        });
        // Print the results.
      print('Confusion matrix:', confusionMatrix);
      print('Overall Accuracy:', confusionMatrix.accuracy());
      print('Producers Accuracy:', confusionMatrix.producersAccuracy());
      print('Consumers Accuracy:', confusionMatrix.consumersAccuracy());
      print('Kappa:', confusionMatrix.kappa());

    return confusionMatrix;
};


/////


///////////
////Validation///

// Función para convertir la propiedad 'nivel_1' de entero a string
var convertNivel1ToString = function(feature) {
    // Obtener el valor actual de 'nivel_1' y convertirlo a string
    var nivel1String = ee.Number(feature.get('nivel_1')).format();

    // Establecer el valor convertido de vuelta en la propiedad 'nivel_1'
    return feature.set('nivel_1', nivel1String);
};

// Aplicar la función a cada Feature en el FeatureCollection
var trainingDataUpdated = S1_training.map(convertNivel1ToString);
var trainingDataUpdated = image_covariates.sampleRegions({
        collection: trainingDataUpdated,
        properties: ['nivel_1'],
        scale: 20
    });

print("trainingDataUpdated 83",trainingDataUpdated);
var testingDataUpdated = S1_testing.map(convertNivel1ToString);


//var RFprim_class_funct=modulo_classifier.RFprim_class(S1_training, inputStack, clase)






exports.importance=function(classifier){
  
  // Run .explain() to see what the classifer looks like
  print(classifier.explain());
  
  // Calculate variable importance
  var importance = ee.Dictionary(classifier.explain().get('importance'));
  
  // Calculate relative importance
  var sum = importance.values().reduce(ee.Reducer.sum());
  
  var relativeImportance = importance.map(function(key, val) {
     return (ee.Number(val).multiply(100)).divide(sum)
    });
  print(relativeImportance);
  
  // Create a FeatureCollection so we can chart it
  var importanceFc = ee.FeatureCollection([
    ee.Feature(null, relativeImportance)
  ]);
  
  var chart = ui.Chart.feature.byProperty({
    features: importanceFc
  }).setOptions({
        title: 'Feature Importance',
        vAxis: {title: 'Importance'},
        hAxis: {title: 'Feature'}
    });
  print(chart);
};