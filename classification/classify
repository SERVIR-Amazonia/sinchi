exports.rf =function RFprim(trainingPts, testingPts,inputImage) {
    var trainingData = inputImage.sampleRegions({
        collection: trainingPts,
        properties: ['nivel_1'],
        scale: 20
    });
    print(" trainingData 7 classify.rf", trainingData);
    
    var testingData = inputImage.sampleRegions({
        collection: testingPts,
        properties: ['nivel_1'],
        scale: 20
    });
    //print(" testingData", testingData)
    
    

    var classifier = ee.Classifier.smileRandomForest(100).train({
        features: trainingData,
        classProperty: 'nivel_1',
        inputProperties: inputImage.bandNames()
    });


    return {
        classified_image: inputImage.classify(classifier),
        rfclassifier: classifier,
        trainingData:testingData,
        testingData:testingData
        
    };
    
};
/////

//// Classiffy with Prmitives

//Funcion para extraer los valores de entrenamiento y validacion de la imagen de covariables
exports.PreparePts = function(S1_training, S1_testing, image_covariates) {
    // Función interna para convertir la propiedad 'nivel_1' de entero a string
    var convertNivel1ToString = function(feature) {
        var nivel1String = ee.Number(feature.get('nivel_1')).format();
        return feature.set('nivel_1', nivel1String);
    };

    // Función para unir las propiedades de dos FeatureCollections
    function joinFeatureCollections(originalFeatures, newPropertiesFeatures, joinKey) {
        var filter = ee.Filter.equals({
            leftField: joinKey,
            rightField: joinKey
        });

        var join = ee.Join.saveAll({
            matchesKey: 'newProperties',
            ordering: joinKey,
            ascending: true
        });

        return join.apply(originalFeatures, newPropertiesFeatures, filter).map(function(feature) {
            var newProps = ee.Feature(ee.List(feature.get('newProperties')).get(0)).toDictionary();
            return feature.set(newProps);
        });
    }

    // Aplicar la función convertNivel1ToString a cada Feature en S1_training y S1_testing
    var trainingDataUpdated = S1_training.map(convertNivel1ToString);
    var testingDataUpdated = S1_testing.map(convertNivel1ToString);

    // Usar sampleRegions para extraer propiedades de la imagen
    var extractedTrainingProperties = image_covariates.sampleRegions({
        collection: trainingDataUpdated,
        properties: ['nivel_1'],
        scale: 20
    });
    var extractedTestingProperties = image_covariates.sampleRegions({
        collection: testingDataUpdated,
        properties: ['nivel_1'],
        scale: 20
    });

    // Unir las propiedades extraídas con los Features originales
    var finalTrainingData = joinFeatureCollections(trainingDataUpdated, extractedTrainingProperties, 'system:index');
    var finalTestingData = joinFeatureCollections(testingDataUpdated, extractedTestingProperties, 'system:index');

    // Retornar ambos datasets actualizados
    return {trainingDataUpdated: finalTrainingData, testingDataUpdated: finalTestingData};
};
//Check and handle missing properties


// Función para verificar y manejar propiedades faltantes
var checkAndHandleMissingProperties=function(feature) {
    var requiredProperties = ['blue', 'green', 'red']; // y otras propiedades relevantes
    var defaultValue = 0; // Define un valor por defecto adecuado

    requiredProperties.forEach(function(prop) {
        // Crear una condición que verifique si la propiedad existe
        var condition = feature.propertyNames().contains(prop);

        // Usar 'ee.Algorithms.If' para manejar la propiedad faltante
        feature = ee.Feature(ee.Algorithms.If(condition, feature, feature.set(prop, defaultValue)));
    });

    return feature;
}

/////////////////////////
/// VAlidación ////
exports.calculateConfusionMatrix = function(testingSet, RFclassifier) {
    var confusionMatrix = testingSet.classify(RFclassifier)
        .errorMatrix({
            actual: 'nivel_1',
            predicted: 'classification'
        });
        // Print the results.
      print('Confusion matrix:', confusionMatrix);
      print('Overall Accuracy:', confusionMatrix.accuracy());
      print('Producers Accuracy:', confusionMatrix.producersAccuracy());
      print('Consumers Accuracy:', confusionMatrix.consumersAccuracy());
      print('Kappa:', confusionMatrix.kappa());

    return confusionMatrix;
};



exports.importance=function(classifier){
  
  // Run .explain() to see what the classifer looks like
  print(classifier.explain());
  
  // Calculate variable importance
  var importance = ee.Dictionary(classifier.explain().get('importance'));
  
  // Calculate relative importance
  var sum = importance.values().reduce(ee.Reducer.sum());
  
  var relativeImportance = importance.map(function(key, val) {
     return (ee.Number(val).multiply(100)).divide(sum)
    });
  print(relativeImportance);
  
  // Create a FeatureCollection so we can chart it
  var importanceFc = ee.FeatureCollection([
    ee.Feature(null, relativeImportance)
  ]);
  
  var chart = ui.Chart.feature.byProperty({
    features: importanceFc
  }).setOptions({
        title: 'Feature Importance',
        vAxis: {title: 'Importance'},
        hAxis: {title: 'Feature'}
    });
  print(chart);
};