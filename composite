/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var geometry = /* color: #d63000 */ee.Geometry.Polygon(
        [[[-71.42833478544651, -0.4710745453900222],
          [-71.28555757004561, -0.4642040686029912],
          [-71.28279257339491, -0.3392525511020995],
          [-71.43109766013782, -0.34748871459006164]]]),
    Region_100K = ee.FeatureCollection("projects/pc300-samz-sinchi/assets/Region_100K");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
/**
 *Este código  genera un mosaico  para procesar imágenes Sentinel-2, eliminando nubes y sombras, y luego calculando NDVI y EVI para las áreas de interés. A continuación, se desglosa cada parte del código:
 *El script procesa imágenes de Sentinel-2 del área de la Amazonía Colombiana durante un 
 *período específico. (Ej. Una imagen por semestre)
 *Primero combina datos de Reflectancia Superficial (SR) de Sentinel-2 con un modelo de probabilidad de nubes. 
 *Luego aplica máscaras para remover nubes y sus sombras y calcula dos índices de vegetación: NDVI y EVI.
 *La salida es una imagen donde, para cada banda (r,g,b) y para cada píxel, se obtiene el percentil 50 de los valores que toma el píxel durante todo el periodo estudiado
**/


/**
 *Definir variables
**/

var CLOUD_FILTER = 70; //Se usará para filtrar imágenes donde más del 70% de los píxeles estén cubiertos por nubes.

var CLD_PRB_THRESH = 40; //Define el umbral de probabilidad de nubes para clasificar píxeles como nube o no nube basado en el modelo s2cloudless. 
                         //Establece un umbral de probabilidad para determinar si un píxel se clasifica como nube o no, según el modelo s2cloudless. 
                         //Es decir, cualquier píxel que tenga una probabilidad superior al 40% de ser una nube se clasificará como tal.

var NIR_DRK_THRESH = 0.15; //Umbral para identificar píxeles oscuros en la banda NIR que no son agua (banda B8). 
                           //Estos píxeles oscuros que no son agua son potencialmente sombras de nubes. 
                           //Si un píxel tiene un valor menor que 0.15 en esta banda, es posible que esté indicando la sombra de una nube.
                          

var CLD_PRJ_DIST = 2; //Distancia máxima (km) para buscar sombras de nubes desde los bordes de las nubes.

var BUFFER = 10;      //Distancia (m) para dilatar el borde de los objetos identificados como nubes

var SR_BAND_SCALE = 1e4; //Almacena el valor 1e4 (10,000). 

var model_inputs = {
    'percentileOptions': [50],// opciones de percentil,en este caso solo se incluye el percentil 50
    };

// Fechas para generar el mosaico
var start_year = 2022;
var start_month = 1;
var start_day = 1;
var end_year = 2022;
var end_month = 6;
var end_day = 30;

// Generar fecha completa
var start_date = ee.Date.fromYMD(start_year, start_month, start_day);
var end_date = ee.Date.fromYMD(end_year, end_month, end_day);


// AOI Amazonia Colombiana
/*
var aoi = geometry; //Define aoi piloto dentro de Amazonia Colombiana para probar el código
*/

//AOI Amazonia Colombiana
var aoi = Region_100K.first().geometry();//AOI para la amazonía Colombiana

/* 
// Visualizar el extent de la Amazonia Colombiana 
 * Map.addLayer(Region_100K, {}, "Region_100K");
 * Map.centerObject(Region_100K);
*/


// get_s2_sr_cld_col almacena una colección de imágenes de reflectancia superficial SR de Sentinel-2,
//Cada imagen está emparejada con datos de probabilidad de nubes.
var get_s2_sr_cld_col = function(aoi, start_date, end_date) {
  
    // s2_sr_col filtra la colección de imágenes SR de Sentinel-2 para el Área de Interés (AOI) y entre las fechas de inicio y fin indicadas.
    // y excluye imágenes con un porcentaje de píxeles nublados mayor al umbral definido en CLOUD_FILTER
    var s2_sr_col = ee.ImageCollection('COPERNICUS/S2_SR')
        .filterBounds(aoi)
        .filterDate(start_date, end_date)
        .filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', CLOUD_FILTER));
    
    //s2_cloudless_col filtra la colección de imágenes S2_CLOUD_PROBABILITY para el AOI y el rango de fechas.
    //La colección S2 cloud probability proporciona datos de probabilidad de nubes
    var s2_cloudless_col = ee.ImageCollection('COPERNICUS/S2_CLOUD_PROBABILITY')
        .filterBounds(aoi)
        .filterDate(start_date, end_date);

    // Une las colecciones SR y s2cloudless basándose en la propiedad 'system:index', 
    // lo que garantiza que cada imagen SR se empareje con su correspondiente imagen de probabilidad de nubes.
    var join = ee.Join.saveFirst('s2cloudless');
    var filter = ee.Filter.equals({
        leftField: 'system:index',
        rightField: 'system:index'
    });
    
    //se aplica la unión entre las dos colecciones de imágenes usando las condiciones definidas anteriormente.
    //La función devuelve una colección de imágenes que contiene las imágenes SR 
    //junto con sus correspondientes datos de probabilidad de nubes.
    return ee.ImageCollection(join.apply({
        primary: s2_sr_col,
        secondary: s2_cloudless_col,
        condition: filter
    }));
};

//Agregar bandas que indican la probabilidad de presencia de nubes 
//y una máscara binaria de nubes a la imagen.
var add_cloud_bands = function(img) {
    var cld_prb = ee.Image(img.get('s2cloudless')).select('probability');// Contiene la imagen con la probabilidad de presencia de nubes en una imagen según el modelo s2cloudless. 
                                                                         //Accede a una imagen que proviene de la colección 's2cloudless'.
    var is_cloud = cld_prb.gt(CLD_PRB_THRESH).rename('clouds');//Contiene una imagen binaria derivada de la probabilidad de nubosidad dada por 's2cloudless'. 
                                                               //Evalúa si los valores en la variable cld_prb  son mayores que el umbral definido en CLD_PRB_THRESH. 
                                                               
    return img.addBands(ee.Image([cld_prb, is_cloud]));//Devuelve imagen binaria donde píxeles con probabilidad de nubosidad mayor que el umbral tienen un valor de 1 y los otros de 0.
};

//Agregar bandas de sombras
//Identifica y proyecta las sombras de las nubes. 
//Luego, añade esta información como nuevas bandas a la imagen original. 
//Utiliza el ángulo azimutal del sol y detecta píxeles oscuros que podrían indicar sombras y realiza una proyección de las sombras desde las ubicaciones de las nubes. 
//Al final, combina la información de píxeles oscuros y las sombras proyectadas.
var add_shadow_bands = function(img) {
    var not_water = img.select('SCL').neq(6);//Imagen binaria. Píxeles con valor 1 representan áreas que no son agua (basado en banda 'SCL' o Scene Classification Map)
                                             //Los píxeles con valor 0 representan áreas de agua. 
                                             //Específicamente, identifica píxeles de agua desde la banda SCL(Scene Classification Map). 
                                             //Banda 'SCL' corresponde a clasificación de coberturas (Ver https://custom-scripts.sentinel-hub.com/custom-scripts/sentinel-2/scene-classification/)
    
    var dark_pixels = img.select('B8').lt(NIR_DRK_THRESH * SR_BAND_SCALE).multiply(not_water).rename('dark_pixels');
    var shadow_azimuth = ee.Number(90).subtract(ee.Number(img.get('MEAN_SOLAR_AZIMUTH_ANGLE')));
    var cld_proj = img.select('clouds').directionalDistanceTransform(shadow_azimuth, CLD_PRJ_DIST * 10)
        .reproject({
            crs: img.select(0).projection(),
            scale: 100
        })
        .select('distance')
        .mask()
        .rename('cloud_transform');
    var shadows = cld_proj.multiply(dark_pixels).rename('shadows');
    return img.addBands(ee.Image([dark_pixels, cld_proj, shadows]));
};

var add_cld_shdw_mask = function(img) {
    var img_cloud = add_cloud_bands(img);
    var img_cloud_shadow = add_shadow_bands(img_cloud);
    var is_cld_shdw = img_cloud_shadow.select('clouds').add(img_cloud_shadow.select('shadows')).gt(0);
    var is_cld_shdw = is_cld_shdw.focal_min(2).focal_max(BUFFER * 2 / 20)
        .reproject({
            crs: img.select([0]).projection(),
            scale: 20
        })
        .rename('cloudmask');
    return img.addBands(is_cld_shdw);
};

var apply_cld_shdw_mask = function(img) {
    var not_cld_shdw = img.select('cloudmask').not();
    return img.select('B.*').updateMask(not_cld_shdw);
};


var add_ndvi = function(img) {
  var ndvi = img.normalizedDifference(['nir', 'red']).rename('NDVI');
  var covariates = ["blue", "green", "red", "nir", "swir1", 'swir2', 'NDVI'];

  img=img.addBands(ndvi);
 img= img.select(covariates);
  return img;
}


// Function to calculate EVI for a single image.
var calculateEVI = function(img) {
  var evi = img.expression(
    '2.5 * (((NIR/10000) - (Red/10000)) / ((NIR/10000) + 6 * (Red/10000) - 7.5 * (Blue/10000) + 1))', {
      'NIR': img.select('nir'),
      'Red': img.select('red'),
      'Blue': img.select('blue')
    });
  return img.addBands(evi.rename('EVI'));
};


//---------------------------//

// Ejecutar todas las funciones de procesamiento de las imagenes

var s2process = function(aoi, start_year, end_year) {
  var start_date = ee.Date.fromYMD(start_year, start_month, start_day);
  var end_date = ee.Date.fromYMD(end_year, end_month, end_day);
    
  var s2_sr_cld_col = get_s2_sr_cld_col(aoi, start_date, end_date);
    
  var imgColl = s2_sr_cld_col.map(add_cld_shdw_mask)
        .map(apply_cld_shdw_mask)
        .select(["B2", "B3", "B4", "B8", "B11", "B12"], ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'])
        .map(add_ndvi).map(calculateEVI);

  var percentile_options = model_inputs['percentileOptions'];	    
  var percentiles = imgColl.reduce(ee.Reducer.percentile({percentiles: percentile_options}));	
   //Omití harmonics
  var stack = ee.Image(percentiles);
  if (model_inputs['addJRCWater']) {
        stack = idx.addJRC(stack).unmask(0);
    }
    
  return stack;
}
   
//---

// Buffer the aoi by 100 m and process the satellite data inside the aoi

var assetId = 'pc300-samz-sinchi';

var region = aoi.buffer(100);
var img = s2process(aoi, start_year, end_year);
// Use your existing 'processedCollection' image (or replace with your actual image)
// Assume processedCollection is your existing image after all the previous processing.
img = img.toFloat();

var mosaic_img = img.select(['blue_p50', 'green_p50', 'red_p50', 'NDVI_p50', 'EVI_p50']);
print(mosaic_img);
var processedCollection = ee.Image(mosaic_img);


// Export the image to an Earth Engine asset.
Export.image.toAsset({
   image: mosaic_img,
   description: 'composite_colombian_amazon_s1',
   assetId: assetId,
   region: region,
   scale: 10,
   maxPixels:  10000000000000 
});

var assetId_temp = 'ee-servir-sinchi-lccv';
// Export the image to a personal Earth Engine asset  I dont have permissions yet.
Export.image.toAsset({
   image: mosaic_img,
   description: 'comp_colomb_amazon_temp_s1',
   assetId: assetId_temp,
   region: region,
   scale: 10,
   maxPixels:  10000000000000 
});


// Visualizing the processed image
//Map.addLayer(img.select('NDVI_p50'), {    min: -1,
//max: 1,    palette: ['blue', 'white', 'green'] }, 'Processed NDVI');

//Map.centerObject(aoi, 12); // Setting the map center to the defined aoi and zoom level 12

